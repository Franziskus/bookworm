package eu.heblich.db;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.sql.Connection;
import java.sql.Date;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Time;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;
import java.util.function.Predicate;

import com.sun.xml.internal.ws.api.pipe.Tube;

import eu.heblich.db.annotation.Id;
import eu.heblich.db.annotation.Ignore;
import eu.heblich.db.annotation.StringSize;

public enum LocalDB {

	INSTANCE;
	
	private Connection con;
	
    public void Init(String driverName, String url, String user, String pass, Map<String, String> systemPropertys){
    	
    	Set<String> keys = systemPropertys.keySet();
    	for (String key : keys) {
    		System.setProperty(key, systemPropertys.get(key));
		}
    	
    	try{
			Class.forName(driverName);			
		}catch(ClassNotFoundException cnfe){
			System.err.println("cnf");
			cnfe.printStackTrace();
		}
		try{
			con=DriverManager.getConnection(url, user, pass);
		}catch(SQLException se){
			System.err.println(url);
			printSQLException(se);
			
		}
    }
    
    public static String stringSQLException(SQLException e)
    {
    	StringWriter sw = new StringWriter();
    	while (e != null)
        {
            sw.write("\n----- SQLException -----");
            sw.write("  SQL State:  ".concat(e.getSQLState()));
            sw.write("  Error Code: ".concat(String.valueOf(e.getErrorCode())));
            sw.write("  Message:    ".concat(e.getMessage()));
            sw.write("  StackReace: ");
            e.printStackTrace(new PrintWriter(sw));
            
            e = e.getNextException();
        }
    	//System.err.println(sw.toString());
    	return sw.toString();
    }
    
    public static void printSQLException(SQLException e)
    {
        // Unwraps the entire exception chain to unveil the real cause of the
        // Exception.
        while (e != null)
        {
        	StringWriter sw = new StringWriter();
        	e.printStackTrace(new PrintWriter(sw));
        	
            System.err.println("\n----- SQLException -----");
            System.err.println("  SQL State:  " + e.getSQLState());
            System.err.println("  Error Code: " + e.getErrorCode());
            System.err.println("  Message:    " + e.getMessage());
            System.err.println("  StackReace: " + sw.toString());
            
            e = e.getNextException();
        }
    }
    
    public void reDeplyAll(Class<?> ... objects ){
    	dropAll(objects);
    	createAll(objects);
    }
    
    public void createAll(Class<?> ... objects ){
    	//String[] names = new String[objects.length];
    	//for (int i = 0; i < names.length; i++) {
		//	names[i] = objects[i].getClass().getSimpleName();
		//}
    	Statement stm=null;
		try{
			stm=con.createStatement();
		}catch(SQLException se){
			printSQLException(se);
		}
    	if(stm != null){
		    for (int i = 0; i < objects.length; i++) {	
		    	try{
		    		Class<?> clazz = objects[i];
		    		String sql="CREATE TABLE ".concat(clazz.getSimpleName()).concat(" (");
		    		Field[] fields = clazz.getDeclaredFields();
		    		boolean hasFirst = false;
		    		for (int j = 0; j < fields.length; j++) {
		    			if(!fields[j].isAnnotationPresent(Ignore.class)){
							String ele = "";
							if(hasFirst)
								ele = ele.concat(", ");
							ele = ele.concat(fields[j].getName()).concat(" ");
							ele = ele.concat(fieldToSQLString(fields[j]));
							sql = sql.concat(ele);
							hasFirst = true;
		    			}
					}
		    		sql = sql.concat("\n)");
		    		System.out.println("LocalDB.createAll: "+sql);
					stm.execute(sql);
				}catch(SQLException se){
					printSQLException(se);
				}
		    }
		    try {
				stm.close();
			} catch (SQLException e) {
				printSQLException(e);
			}
	    }
    	
    }
    
    private String fieldToSQLString(Field f){
    	String s = "";
    	if(f.isAnnotationPresent(StringSize.class)){
    		StringSize ann = f.getDeclaredAnnotation(StringSize.class);
    		s = s.concat("VARCHAR(").concat(String.valueOf(ann.value())).concat(") ");
    	}else{
    		s = s.concat(typeToSQLString(f.getType())).concat(" ");
    	}
    	if(f.isAnnotationPresent(Id.class)){
    		Id ann = f.getDeclaredAnnotation(Id.class);
    		//INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    		if(ann.autogenerated())
    			s = s.concat("GENERATED BY DEFAULT AS IDENTITY ");
    		s = s.concat(" PRIMARY KEY ");
    	}
    	return s;
    }
    
    @SuppressWarnings("unchecked")
	private <T> T stringToType(Class<T> type, String s){
    	if(type == String.class){
    		return (T) s;
    	}else if(type.isPrimitive() && type == int.class){
    		//return (T)Integer.parseInt(s);
    		return (T)new Integer(s);
    	}else if(type == Integer.class){
    		return (T)new Integer(s);
    	}else if(type.isPrimitive() && type == float.class){
    		return (T)new Float(s);
    	}else if(type == Float.class){
    		return (T)new Float(s);
    	}else if(type.isPrimitive() && type == double.class){
    		return (T)new Double(s);
    	}else if(type == Double.class){
    		return (T)new Double(s);
    	}else if(type.isPrimitive() && type == boolean.class){
    		return (T)((s.equals(0))?new Boolean(false):new Boolean(true));
    	}else if(type == Boolean.class){
    		return (T)((s.equals(0))?new Boolean(false):new Boolean(true));
    	}else if(type.isPrimitive() && type == long.class){
    		return (T)new Long(s);
    	}else if(type == Long.class){
    		return (T)new Long(s);
    	}else if(type.isPrimitive() && type == short.class){
    		return (T)new Short(s);
    	}else if(type == Short.class){
    		return (T)new Short(s);
    	}else if(type.isPrimitive() && type == byte.class){
    		return (T)new Byte(s);
    	}else if(type == Byte.class){
    		return (T)new Byte(s);
    	}else if(type.isPrimitive() && type == char.class){
    		return (T)new Character(s.toString().charAt(0));
    	}else if(type == Character.class){
    		return (T)new Character(s.toString().charAt(0));
    	}else if(type == Date.class){
    		return (T)new Date(Long.parseLong(s));
    	}else if(type == Time.class){
    		return (T)new Time(Long.parseLong(s));
    	}else if(type == Timestamp.class){
    		return (T)new Timestamp(Long.parseLong(s));
    	}
    	throw new IllegalArgumentException("Can't find derby sql type for "+type.getCanonicalName());
    }
    
    
    private String typeToSQLString(Class<?> type){
    	if(type == String.class){
    		return "VARCHAR(255)";
    	}else if(type.isPrimitive() && type == int.class){
    		return "INTEGER";
    	}else if(type == Integer.class){
    		return "INTEGER";
    	}else if(type.isPrimitive() && type == float.class){
    		return "FLOAT";
    	}else if(type == Float.class){
    		return "FLOAT";
    	}else if(type.isPrimitive() && type == double.class){
    		return "FLOAT";
    	}else if(type == Double.class){
    		return "FLOAT";
    	}else if(type.isPrimitive() && type == boolean.class){
    		return "SMALLINT";
    	}else if(type == Boolean.class){
    		return "SMALLINT";
    	}else if(type.isPrimitive() && type == long.class){
    		return "BIGINT";
    	}else if(type == Long.class){
    		return "BIGINT";
    	}else if(type.isPrimitive() && type == short.class){
    		return "SMALLINT";
    	}else if(type == Short.class){
    		return "SMALLINT";
    	}else if(type.isPrimitive() && type == byte.class){
    		return "SMALLINT";
    	}else if(type == Byte.class){
    		return "SMALLINT";
    	}else if(type.isPrimitive() && type == char.class){
    		return "CHAR(1)";
    	}else if(type == Character.class){
    		return "CHAR(1)";
    	}else if(type == Date.class){
    		return "DATE";
    	}else if(type == Time.class){
    		return "TIME";
    	}else if(type == Timestamp.class){
    		return "TIMESTAMP";
    	}
    	throw new IllegalArgumentException("Can't find derby sql type for "+type.getCanonicalName());
    	
    }
    
    public boolean insert(Object values){
    	String table = values.getClass().getSimpleName();
    	Field[] fields = values.getClass().getDeclaredFields();
    	List<String> names = new ArrayList<>();
		boolean hasFirst = false;
		
		for (int j = 0; j < fields.length; j++) {
			if(!fields[j].isAnnotationPresent(Ignore.class)){
				if(fields[j].isAnnotationPresent(Id.class)){
					try {
						if(fields[j].get(values) != null)
							names.add(fields[j].getName());
						else
							fields[j] = null;
					} catch (IllegalArgumentException | IllegalAccessException e) {
						e.printStackTrace();
					} 
				}else{
					names.add(fields[j].getName());	
				}
			}
		}
		
    	
		String sql = "";
    	Statement selStm = null;
		try{
			selStm = con.createStatement();
			//ResultSet result= selStm.executeQuery("SELECT * FROM "+table);

			//ResultSetMetaData rsmd = result.getMetaData();
			//int numberCols = rsmd.getColumnCount();

			//String[]columnNames = new String[numberCols];
			//for (int i=1; i<=numberCols; i++){
			//	columnNames[i-1] = rsmd.getColumnLabel(i);  
			//}
			

			sql = "INSERT INTO "+table+" (";
			
			for (int i = 0; i < names.size(); i++) {
				if(i!=0)
					sql += ", ";
				sql += names.get(i);
			}
			
			
			sql += ") VALUES (";
			
			boolean fist = true;
			for (int j = 0; j < fields.length; j++) {
				if(fields[j] != null && !fields[j].isAnnotationPresent(Ignore.class)){
					if(!fist)
						sql += ", ";
					Object back = fields[j].get(values);
					if(back instanceof String)
						back = "'".concat(back.toString()).concat("'");
					sql = sql .concat((back == null)?"null":back.toString());
					fist = false;
				}
			}
			
			
			sql += ")";
			//System.out.println("LocalDB.insert: "+sql);
			return selStm.execute(sql);
		}catch (SQLException e) {
			System.out.println("LocalDB.insert: "+sql);
			printSQLException(e);
			return false;
		}catch(Exception e1){
			System.out.println("LocalDB.insert: "+sql);
			e1.printStackTrace();
			return false;
		}finally{
			if(selStm != null)
				try {
					selStm.close();
				} catch (SQLException e) {
					printSQLException(e);
				}
		}
	}
    
    public boolean update(Object values){
    	String table = values.getClass().getSimpleName();
    	Field[] fields = values.getClass().getDeclaredFields();
    	List<String> names = new ArrayList<>();
		Field idField = null;
    	
		for (int j = 0; j < fields.length; j++) {
			if(!fields[j].isAnnotationPresent(Ignore.class)){
				if(fields[j].isAnnotationPresent(Id.class)){
					idField = fields[j];
					try {
						if(fields[j].get(values) != null)
							names.add(fields[j].getName());
						else
							fields[j] = null;
					} catch (IllegalArgumentException | IllegalAccessException e) {
						e.printStackTrace();
					} 
				}else{
					names.add(fields[j].getName());	
				}
			}
		}
    	
    	
    	Statement selStm = null;
		try{
			selStm = con.createStatement();
			//ResultSet result= selStm.executeQuery("SELECT * FROM "+table);

			//ResultSetMetaData rsmd = result.getMetaData();
			//int numberCols = rsmd.getColumnCount();

			//String[]columnNames = new String[numberCols];
			//for (int i=1; i<=numberCols; i++){
			//	columnNames[i-1] = rsmd.getColumnLabel(i);  
			//}
			

			String sql = "UPDATE "+table+" SET ";
			
			for (int i = 0; i < names.size(); i++) {
				if(i!=0)
					sql += ", ";
				sql += names.get(i);
				sql += " = ";
				Field fittingField = values.getClass().getDeclaredField(names.get(i));
				Object back = fittingField.get(values);
				if(back instanceof String)
					back = "'".concat(back.toString()).concat("'");
				sql = sql.concat((back == null)?"null":back.toString());
			}
			
			
			sql += " WHERE "+idField.getName() +" = "+idField.get(values).toString();
			
			
			
			System.out.println("LocalDB.update: "+sql);
			return selStm.execute(sql);
		}catch (SQLException e) {
			printSQLException(e);
			return false;
		}catch(Exception e1){
			e1.printStackTrace();
			return false;
		}finally{
			if(selStm != null)
				try {
					selStm.close();
				} catch (SQLException e) {
					printSQLException(e);
				}
		}
	}
    
    private Method fineSetMethod(Class<?> clazz, Class<?> parameterType, String name) throws NoSuchMethodException, SecurityException{
    	String methodName = "set";
    	methodName += name.substring(0, 1).toUpperCase().concat(name.substring(1));
    	return clazz.getDeclaredMethod(methodName, parameterType);
    }
    
    
    public <T> T get(Class<T> clazz, Object id){
    	String table = clazz.getSimpleName();
    	Field[] fields = clazz.getDeclaredFields();
    	List<Field> names = new ArrayList<>();
		Field idField = null;
		boolean content = false;
    	
		for (int j = 0; j < fields.length; j++) {
			if(!fields[j].isAnnotationPresent(Ignore.class)){
				if(fields[j].isAnnotationPresent(Id.class)){
					idField = fields[j];
				}
				names.add(fields[j]);	
			}
		}
		String sql = "SELECT ";
    	
		for (int i = 0; i < names.size(); i++) {
			if(i!=0)
				sql += ", ";
			sql += names.get(i).getName();
		}
		sql += " FROM ".concat(table);
		sql += " WHERE ";
		sql += idField.getName();
		//sql += " = ";
		if(id instanceof String)
			sql += "like '".concat(id.toString()).concat("'");
		else
		    sql += " = ".concat(((id == null)?"null":id.toString()));
		
		T back;
		try {
			back = clazz.newInstance();
		} catch (InstantiationException | IllegalAccessException e1) {
			e1.printStackTrace();
			return null;
		}
		
		Statement stm=null;
		try{
			stm=con.createStatement();
		}catch(SQLException se){
			printSQLException(se);
		}
    	if(stm != null){
    		ResultSet set = null;
			try {
				set = stm.executeQuery(sql);
				while (set.next()) {
					content = true;
					for (int i = 0; i < names.size(); i++) {
						Method m =fineSetMethod(clazz, names.get(i).getType(), names.get(i).getName());
						Object o = stringToType(names.get(i).getType(), set.getObject(i+1).toString());
						// Unsure if this is needed? found the bug somware elese
						if(names.get(i).getType().isPrimitive()){
							if(o instanceof Integer)
								m.invoke(back, ((Integer)o).intValue());
							else if(o instanceof Float)
								m.invoke(back, ((Float)o).floatValue());
							else if(o instanceof Double)
								m.invoke(back, ((Double)o).doubleValue());
							else if(o instanceof Boolean)
								m.invoke(back, ((Boolean)o).booleanValue());
							else if(o instanceof Long)
								m.invoke(back, ((Long)o).longValue());
							else if(o instanceof Short)
								m.invoke(back, ((Short)o).shortValue());
							else if(o instanceof Byte)
								m.invoke(back, ((Byte)o).byteValue());
							else if(o instanceof Character)
								m.invoke(back, ((Character)o).charValue());
						}else{
						//end of unsure
							m.invoke(back, o);	
						}
					}
				}
				
			} catch (SQLException | NoSuchMethodException | SecurityException | IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
				System.out.println("LocalDB.get: "+ sql);
				if(e instanceof SQLException)
					printSQLException((SQLException)e);
				else
					e.printStackTrace();
				content = false;
			}
    		try {
    			if(set != null)
    				set.close();
			} catch (SQLException e) {
				printSQLException(e);
			}
    		try {
    			if(stm != null)
    				stm.close();
			} catch (SQLException e) {
				printSQLException(e);
			}
    	}
		
		
		
		if(!content)
			return null;
		return back;
	}
	
    
    
    public void dropAll(Class<?> ... objects ){
    	String[] names = new String[objects.length];
    	for (int i = 0; i < names.length; i++) {
			names[i] = objects[i].getSimpleName();
		}
    	Statement stm=null;
		try{
			stm=con.createStatement();
		}catch(SQLException se){
			printSQLException(se);
		}
    	if(stm != null){
		    for (int i = 0; i < names.length; i++) {	
		    	try{
		    		//String check = "select count(*) from sys.systables where tablename = '".concat(names[i]).concat("'");
		    		//System.out.println("execute "+check);
		    		//ResultSet res = stm.executeQuery(check); 
		    		//while (res.next()){
		    		//	System.out.println("look "+res.getInt(1));
		    		//	if(res.getInt(1) > 0){
		    		{
		    			{
		    				String sql="DROP TABLE ".concat(names[i]).concat("");
							stm.execute(sql);
		    			}
		    		}
		    		//res.close();		    		
				}catch(SQLException se){
					printSQLException(se);
				}
		    }
		    try {
				stm.close();
			} catch (SQLException e) {
				printSQLException(e);
			}
	    }
    	
    }
    
    public void select(String select, Consumer<ResultSet> consum){
    	Statement stm=null;
		try{
			stm=con.createStatement();
		}catch(SQLException se){
			printSQLException(se);
		}
    	if(stm != null){
    		ResultSet set = null;
			try {
				set = stm.executeQuery(select);
				consum.accept(set);
			} catch (SQLException e) {
				System.out.println("LocalDB.select: "+select);
				printSQLException(e);
			}
    		try {
    			if(set != null)
    				set.close();
			} catch (SQLException e) {
				printSQLException(e);
			}
    		try {
    			if(stm != null)
    				stm.close();
			} catch (SQLException e) {
				printSQLException(e);
			}
    	}
    }
    
    public void shutdownConnection(){
		try{
			DriverManager.getConnection("jdbc:derby:;shutdown=true");
		}catch(SQLException se){
			if (((se.getErrorCode() == 50000)
	                && ("XJ015".equals(se.getSQLState())))) {
				System.err.println("Derby shut down normally"+ se);
			}else{
				printSQLException(se);
			}
    	} finally {
    		if(con != null){
				try {
					con.close();
				} catch (SQLException e) {
					printSQLException(e);
				}
    		}
    	}
		con = null;
	}

	public Connection getConnection() {
		return con;
	}
    
    
}
